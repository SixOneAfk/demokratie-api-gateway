<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Room</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #error { color: white; font-family: Arial; padding: 20px; }
    #videoOverlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.75); display: none; align-items: center; justify-content: center; z-index: 10; }
    #videoOverlay video { max-width: 80vw; max-height: 80vh; border-radius: 8px; background: #000; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
    #closeVideoBtn { position: absolute; top: 30px; right: 40px; background: rgba(0, 0, 0, 0.65); color: #fff; border: none; padding: 10px 16px; font-size: 16px; cursor: pointer; border-radius: 4px; }
    #closeVideoBtn:hover { background: rgba(0, 0, 0, 0.85); }
    </style>
</head>
<body>
    <div id="error" style="display: none;"></div>
    <div id="videoOverlay">
        <button id="closeVideoBtn">Закрыть</button>
        <video id="roomVideo" controls></video>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        try {
            // Проверяем поддержку WebGL
            if (!window.WebGLRenderingContext) {
                throw new Error('WebGL not supported');
            }

            // Создаем сцену
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Голубой фон (небо)
            const interactables = [];
            
            // Добавляем fog для эффекта расстояния
            scene.fog = new THREE.Fog(0x87CEEB, 5, 15); // Цвет, ближняя дистанция, дальняя дистанция

            // Камера (первый человек)
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 5); // Высота глаз человека

            // Рендерер
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const videoOverlay = document.getElementById('videoOverlay');
            const roomVideo = document.getElementById('roomVideo');
            const closeVideoBtn = document.getElementById('closeVideoBtn');

            closeVideoBtn.addEventListener('click', closeVideo);
            videoOverlay.addEventListener('click', (event) => {
                if (event.target === videoOverlay) {
                    closeVideo();
                }
            });
            roomVideo.addEventListener('ended', closeVideo);

            // Освещение
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // Создаем стены комнаты (простые плоскости)
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0xf0f0f0 });

            // Пол с текстурой плитки
            const floorTexture = new THREE.TextureLoader().load('data:image/svg+xml;base64,' + btoa(`
                <svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <pattern id="tile" patternUnits="userSpaceOnUse" width="50" height="50">
                            <rect width="50" height="50" fill="#e0e0e0"/>
                            <rect x="25" y="25" width="25" height="25" fill="#d0d0d0"/>
                        </pattern>
                    </defs>
                    <rect width="100" height="100" fill="url(#tile)"/>
                </svg>
            `));
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(4, 4); // Повторяем текстуру 4x4 раза
            
            const floorMaterial = new THREE.MeshLambertMaterial({ map: floorTexture });
            const floorGeometry = new THREE.PlaneGeometry(10, 10);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // Потолок с текстурой плитки (другие цвета)
            const ceilingTexture = new THREE.TextureLoader().load('data:image/svg+xml;base64,' + btoa(`
                <svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <pattern id="ceilingTile" patternUnits="userSpaceOnUse" width="50" height="50">
                            <rect width="50" height="50" fill="#f8f8f8"/>
                            <rect x="25" y="25" width="25" height="25" fill="#e8e8e8"/>
                        </pattern>
                    </defs>
                    <rect width="100" height="100" fill="url(#ceilingTile)"/>
                </svg>
            `));
            ceilingTexture.wrapS = THREE.RepeatWrapping;
            ceilingTexture.wrapT = THREE.RepeatWrapping;
            ceilingTexture.repeat.set(4, 4);
            
            const ceilingMaterial = new THREE.MeshLambertMaterial({ map: ceilingTexture });
            const ceilingGeometry = new THREE.PlaneGeometry(10, 10);
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = 5;
            scene.add(ceiling);

            // Стены (левая, правая, задняя, передняя) - позиционируем правильно
            const wallGeometry = new THREE.PlaneGeometry(10, 5);

            const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
            leftWall.position.set(-5, 2.5, 0); // Центр стены на высоте 2.5
            leftWall.rotation.y = Math.PI / 2;
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
            rightWall.position.set(5, 2.5, 0);
            rightWall.rotation.y = -Math.PI / 2;
            scene.add(rightWall);

            const backWall = new THREE.Mesh(wallGeometry, wallMaterial);
            backWall.position.set(0, 2.5, -5);
            scene.add(backWall);

            // Простая картина на задней стене
            const pictureTexture = new THREE.TextureLoader().load('data:image/svg+xml;base64,' + btoa(`
                <svg width="400" height="240" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="sky" x1="0" y1="0" x2="0" y2="1">
                            <stop offset="0%" stop-color="#87ceeb"/>
                            <stop offset="70%" stop-color="#f5deb3"/>
                        </linearGradient>
                        <radialGradient id="sun" cx="0.8" cy="0.2" r="0.2">
                            <stop offset="0%" stop-color="#fffacd"/>
                            <stop offset="100%" stop-color="#f1c40f"/>
                        </radialGradient>
                    </defs>
                    <rect width="400" height="240" fill="url(#sky)"/>
                    <circle cx="320" cy="60" r="35" fill="url(#sun)"/>
                    <path d="M0 160 L120 90 L240 160 Z" fill="#2ecc71"/>
                    <path d="M80 160 L200 100 L320 160 Z" fill="#27ae60"/>
                    <rect x="170" y="140" width="20" height="40" fill="#8d5524"/>
                    <circle cx="180" cy="130" r="30" fill="#2c3e50"/>
                </svg>
            `));
            pictureTexture.colorSpace = THREE.SRGBColorSpace;

            const pictureGeometry = new THREE.PlaneGeometry(2, 1.2);
            const pictureMaterial = new THREE.MeshLambertMaterial({ map: pictureTexture });
            const picture = new THREE.Mesh(pictureGeometry, pictureMaterial);
            picture.position.set(0, 2.5, -4.99);
            scene.add(picture);

            const frameGeometry = new THREE.PlaneGeometry(2.1, 1.3);
            const frameMaterial = new THREE.MeshBasicMaterial({ color: 0x8b5a2b });
            const frame = new THREE.Mesh(frameGeometry, frameMaterial);
            frame.position.set(0, 2.5, -4.995);
            scene.add(frame);

            const hotspotGeometry = new THREE.CircleGeometry(0.15, 32);
            const hotspotMaterial = new THREE.MeshBasicMaterial({ color: 0xff8c00, side: THREE.DoubleSide });
            const hotspot = new THREE.Mesh(hotspotGeometry, hotspotMaterial);
            hotspot.position.set(1.3, 2.3, -4.98);
            hotspot.userData = { videoId: 1 };
            scene.add(hotspot);
            interactables.push(hotspot);

            // Добавим переднюю стену
            const frontWall = new THREE.Mesh(wallGeometry, wallMaterial);
            frontWall.position.set(0, 2.5, 5);
            frontWall.rotation.y = Math.PI;
            scene.add(frontWall);

            // Контроллер для передвижения
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.enableZoom = true;
            controls.enablePan = false;
            controls.enableKeys = false; // Отключаем клавиши для OrbitControls

            const raycaster = new THREE.Raycaster();
            const pointer = new THREE.Vector2();

            // Добавляем управление клавишами WASD (используем event.code, чтобы работать при разных раскладках)
            const keys = { KeyW: false, KeyA: false, KeyS: false, KeyD: false };
            const moveSpeed = 0.1;
            const moveVector = new THREE.Vector3();

            // Добавляем фокус на canvas
            renderer.domElement.tabIndex = 0;
            renderer.domElement.focus();
            renderer.domElement.addEventListener('click', () => renderer.domElement.focus());

            window.addEventListener('keydown', (event) => {
                if (event.code in keys) {
                    keys[event.code] = true;
                    event.preventDefault();
                    event.stopPropagation();
                }
            });

            window.addEventListener('keyup', (event) => {
                if (event.code in keys) {
                    keys[event.code] = false;
                    event.preventDefault();
                    event.stopPropagation();
                }
            });

            renderer.domElement.addEventListener('pointerdown', onPointerDown);

            function onPointerDown(event) {
                if (videoOverlay.style.display === 'flex') {
                    return;
                }

                const rect = renderer.domElement.getBoundingClientRect();
                pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(pointer, camera);
                const intersects = raycaster.intersectObjects(interactables, false);

                if (intersects.length > 0) {
                    const { videoId } = intersects[0].object.userData || {};
                    if (typeof videoId === 'number') {
                        playVideo(videoId);
                    }
                }
            }

            // Анимация
            function animate() {
                requestAnimationFrame(animate);

                // Движение камеры по WASD (относительно направления взгляда)
                const forward = new THREE.Vector3().subVectors(controls.target, camera.position);
                forward.y = 0;
                if (forward.lengthSq() === 0) forward.z = -1; // fallback, если камера совпала с целью
                forward.normalize();

                const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();

                moveVector.set(0, 0, 0);
                if (keys.KeyW) moveVector.add(forward);
                if (keys.KeyS) moveVector.sub(forward);
                if (keys.KeyA) moveVector.sub(right);
                if (keys.KeyD) moveVector.add(right);

                if (moveVector.lengthSq() > 0) {
                    moveVector.normalize().multiplyScalar(moveSpeed);
                    camera.position.add(moveVector);
                    controls.target.add(moveVector);
                }

                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            function playVideo(videoId) {
                controls.enabled = false;
                roomVideo.pause();
                const streamUrl = `/video/${videoId}`;
                roomVideo.src = streamUrl;
                roomVideo.load();
                videoOverlay.style.display = 'flex';
                roomVideo.play().catch(() => {
                    // Игнорируем ошибки автозапуска; пользователь сможет нажать Play вручную
                });
            }

            function closeVideo() {
                roomVideo.pause();
                roomVideo.removeAttribute('src');
                roomVideo.load();
                videoOverlay.style.display = 'none';
                controls.enabled = true;
                renderer.domElement.focus();
            }

            // Обработка изменения размера окна
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            console.log('3D Room loaded successfully');

        } catch (error) {
            console.error('Error loading 3D room:', error);
            document.getElementById('error').style.display = 'block';
            document.getElementById('error').innerHTML = 'Error loading 3D scene: ' + error.message + '<br>Check browser console for details.';
        }
    </script>
</body>
</html>
